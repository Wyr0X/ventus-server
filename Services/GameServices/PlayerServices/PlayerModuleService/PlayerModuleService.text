using System;
using System.Threading.Tasks;

public interface IHasPlayerId
{
    int PlayerId { get; set; }
}

public class PlayerModuleService<TModel, TEntity> : IPlayerModuleService<TModel>
    where TModel : class
    where TEntity : class, IHasPlayerId
{
    private readonly IRepository<TEntity> _repository;
    private readonly ICacheService _cache;

    public PlayerModuleService(IRepository<TEntity> repository, ICacheService cache)
    {
        _repository = repository;
        _cache = cache;
    }

    // Obtiene el módulo del jugador desde la base de datos o caché
    public async Task<TModel> GetPlayerModuleAsync(int playerId)
    {
        // Verificar si el módulo está en caché
        var cachedModule = _cache.Get<TModel>($"playerModule_{playerId}_{typeof(TModel).Name}");
        if (cachedModule != null)
        {
            return cachedModule; // Retornar si se encuentra en caché
        }

        // Si no está en caché, cargar desde la base de datos
        var entity = await _repository.GetByPlayerIdAsync(playerId);
        if (entity == null)
        {
            throw new KeyNotFoundException($"No se encontró el módulo para el jugador con ID: {playerId}");
        }

        // Convertir la entidad a modelo de dominio usando el GenericMapper
        var model = GenericMapper.ToDomainModel<TEntity, TModel>(entity);

        // Almacenar el módulo en caché para futuras consultas
        _cache.Set($"playerModule_{playerId}_{typeof(TModel).Name}", model);

        return model;
    }

    // Actualiza el módulo del jugador en la base de datos y caché
    public void UpdatePlayerModule(TModel model)
    {
        // Guardar en caché para reducir el número de escrituras a la base de datos
        _cache.Set($"playerModule_{model.GetType().Name}", model);

        // Convertir el modelo de dominio a la entidad
        var entity = GenericMapper.ToEntity<TModel, TEntity>(model);

        // Actualizar la base de datos
        _repository.Update(entity);
    }

    // Guarda o actualiza el módulo del jugador en la base de datos
    public async Task SavePlayerModuleAsync(TModel model)
    {
        // Convertir el modelo de dominio a la entidad utilizando el GenericMapper
        var entity = GenericMapper.ToEntity<TModel, TEntity>(model);

        // Verificar si la entidad ya existe en la base de datos
        var existingEntity = await _repository.GetByPlayerIdAsync(model.PlayerId);

        if (existingEntity != null)
        {
            // Si existe, actualizar la entidad con los valores del modelo de dominio
            _repository.Update(entity);
        }
        else
        {
            // Si no existe, agregar una nueva entidad
            await _repository.AddAsync(entity);
        }

        // Guardar los cambios en la base de datos
        await _repository.SaveChangesAsync();
    }

    // Elimina el módulo del jugador de la base de datos
    public async Task DeletePlayerModuleAsync(int playerId)
    {
        // Obtener la entidad del jugador por ID
        var entity = await _repository.GetByPlayerIdAsync(playerId);

        if (entity == null)
        {
            throw new KeyNotFoundException($"Módulo de jugador con ID {playerId} no encontrado.");
        }

        // Eliminar la entidad de la base de datos
        await _repository.DeleteAsync(entity);

        // Guardar los cambios
        await _repository.SaveChangesAsync();

        // Eliminar la caché relacionada
        _cache.Remove($"playerModule_{playerId}_{typeof(TModel).Name}");
    }
}
